import { CodeSurfer, CodeSurferColumns, Step as CSStep } from 'code-surfer'
import { nightOwl } from "@code-surfer/themes"

export const theme = nightOwl

# Let's make a Promise

Or: _How I learned to stop using callbacks and love the `Promise` implementation_

---

## Required knowledge

- Common data types (primitives, arrays, and objects)
- Functions, particularly as a first class data type

---

## A refresher on First Class Functions

<CodeSurfer>

```js
setTimeout(() => {
  console.log('Hello, world!')
}, 1000)
```

```js 1[1:11],3[8]
setTimeout(() => {
  console.log('Hello, world!')
}, 1000)
```

```js 1[12:19],2,3[1]
setTimeout(() => {
  console.log('Hello, world!')
}, 1000)
```

```js 3[4:7]
setTimeout(() => {
  console.log('Hello, world!')
}, 1000)
```

```js 1[12:19],2,3[1]
setTimeout(() => {
  console.log('Hello, world!')
}, 1000)
```

```js 1[18:24],2,3[1]
const sayHello = () => {
  console.log('Hello, world!')
}

setTimeout(sayHello, 1000)
```

```js
const sayHello = () => {
  console.log('Hello, world!')
}

setTimeout(sayHello, 1000)
```

```js 5[22:25]
const sayHello = () => {
  console.log('Hello, world!')
}

setTimeout(sayHello, 1000)
```

```js 5,7[22:28]
const sayHello = () => {
  console.log('Hello, world!')
}

const timeout = 1000

setTimeout(sayHello, timeout)
```

```js
const sayHello = () => {
  console.log('Hello, world!')
}

const timeout = 1000

setTimeout(sayHello, timeout)
```

</CodeSurfer>

<Notes>

In JavaScript, functions are First Class Citizens. I.e. they can be passed around like all other data types.

</Notes>

---

<CodeSurfer>

```js
setTimeout(() => {
  console.log('Hello, world!')
}, 1000)
```

</CodeSurfer>

is equivalent to

<CodeSurfer>

```js
const sayHello = () => {
  console.log('Hello, world!')
}

const timeout = 1000

setTimeout(sayHello, timeout)
```

</CodeSurfer>

---

## What this won't cover

- `async`/`await`
- A lot of the extra features that the `Promise` implementation offers
- Why leaves are usually green

<Notes>

- async/await is certainly useful, but a solid understanding of Promises is what you really need to leverage it properly
- Promise.all, Promise.race, Promise.any (though I challenge you to implement these yourself after today's talk)

</Notes>

---

## Okay, so what's a Promise?

<Steps>

> “The `Promise` object represents the **eventual completion (or failure)** of an asynchronous operation and its **resulting value**.”
– MDN

</Steps>

<Notes>

- That's spot on. But also pretty useless on its own

</Notes>

---

## What does that look like in action?

<CodeSurfer>

```js
eventualGreeting()
  .then(console.log)
  .catch(console.error)

// eventually logs "Hello, world!", or logs an error
```

</CodeSurfer>

---

## How does a Promise get created?

<CodeSurfer>

```js
new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('Hello, world!')
  }, 1000)
})
```

```js 1[1:12],5[2]
new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('Hello, world!')
  }, 1000)
})
```

```js 1[13:34],5[1]
new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('Hello, world!')
  }, 1000)
})
```

```js 1[22:43],5[1] subtitle="Let's give that function a name"
const promiseLogic = (resolve, reject) => {
  setTimeout(() => {
    resolve('Hello, world!')
  }, 1000)
}

new Promise(promiseLogic)
```

```js 1[7:18],7[13:24] subtitle="Let's give that function a name"
const promiseLogic = (resolve, reject) => {
  setTimeout(() => {
    resolve('Hello, world!')
  }, 1000)
}

new Promise(promiseLogic)
```

```js 2:4 subtitle="This should look familiar"
const promiseLogic = (resolve, reject) => {
  setTimeout(() => {
    resolve('Hello, world!')
  }, 1000)
}

new Promise(promiseLogic)
```

```js 1[23:29],3
const promiseLogic = (resolve, reject) => {
  setTimeout(() => {
    resolve('Hello, world!')
  }, 1000)
}

new Promise(promiseLogic)
```

```js
const promiseLogic = (resolve, reject) => {
  setTimeout(() => {
    resolve('Hello, world!')
  }, 1000)
}

new Promise(promiseLogic)
```

```js 7 subtitle="This will immediately create the Promise and execute promiseLogic"
const promiseLogic = (resolve, reject) => {
  setTimeout(() => {
    resolve('Hello, world!')
  }, 1000)
}

new Promise(promiseLogic)
```

```js 7 subtitle="So let's wrap a function around it so it won't do anything until we call it"
const promiseLogic = (resolve, reject) => {
  setTimeout(() => {
    resolve('Hello, world!')
  }, 1000)
}

const eventualGreeting = () => new Promise(promiseLogic)
```

```js
const promiseLogic = (resolve, reject) => {
  setTimeout(() => {
    resolve('Hello, world!')
  }, 1000)
}

const eventualGreeting = () => new Promise(promiseLogic)

eventualGreeting()
  .then(console.log)
  .catch(console.error)
```

</CodeSurfer>

<Notes>

- Whatever you call `resolve` with becomes what the `Promise` resolves with. In this case, a string

</Notes>

---

# Extra features of Promises

---

### A Promise always returns a Promise

<Notes>

- Let's assume we have a function which returns a Promise which adds one to whatever we give it, after one second.

</Notes>

<CodeSurfer>

```js
eventuallyAddOne(5)
  .then(console.log)

// Eventually gives us 6
```

```js title="Wow this is awful"
eventuallyAddOne(5)
  .then((resultOne) => {
    return eventuallyAddOne(resultOne)
      .then((resultTwo) => {
        return eventuallyAddOne(resultTwo)
          .then((resultThree) => {
            console.log(resultThree)
          })
      })
  })

// Eventually gives us 8
```

```js title="This is fair bit better"
eventuallyAddOne(5)
  .then((result) => eventuallyAddOne(result))
  .then((result) => eventuallyAddOne(result))
  .then(console.log)

// Eventually gives us 8
```

```js title="This makes me happy"
eventuallyAddOne(5)
  .then(eventuallyAddOne)
  .then(eventuallyAddOne)
  .then(console.log)

// Eventually gives us 8
```

</CodeSurfer>

---

### No, really, a Promise _always_ returns a Promise

<Notes>

- Let's assume we have a _synchronous_ function which subtracts two

</Notes>

<CodeSurfer>

```js
const takeTwo = (input) => input - 2
```

```js
const takeTwo = (input) => input - 2

eventuallyAddOne(5)
  .then(takeTwo)
  .then(console.log)

// Eventually gives us 4
```

```js title="You could be here for a while. You get the idea."
eventuallyAddOne(5)
  .then(takeTwo)
  .then(takeTwo)
  .then(eventuallyAddOne)
  .then(takeTwo)
  .then(eventuallyAddOne)
  .then(console.log)
```

</CodeSurfer>

---

### You can share Promises

<CodeSurfer>

```js title="This is totally valid and works"
const myFirstPromise = eventuallyAddOne(5)

myFirstPromise
  .then(takeTwo)
  .then(console.log)

myFirstPromise
  .then(eventuallyAddOne)
  .then(console.log)
```

</CodeSurfer>

<Notes>

- Note there is one Promise to start with, but two distinct Promise _chains_ which depend on that first Promise resolving

</Notes>

---

## We've got a pretty good idea of what we can do with Promises

---

## We've made Promises

---

# Now let's make `Promise`

---

## Promises are Finite State Machines

<img style={{ maxWidth: '80%' }} src='https://media.prod.mdn.mozit.cloud/attachments/2018/04/18/15911/32e79f722e83940fdaea297acdb5df92/promises.png' />

<Notes>

- three states: pending, fulfilled, rejected
- a *new* promise is returned from invoking `.then` or `.catch`

</Notes>

---

## A quick reminder

> “The `Promise` object represents the **eventual completion (or failure)** of an asynchronous operation and its **resulting value**.”
– MDN

---

### Let's start off our state tracking

<CodeSurfer>

```js
function Promise () {
  // TODO: Implement Promises
}
```

```js
function Promise () {
  let state = 'PENDING'
}
```

```js
function Promise () {
  let state = 'PENDING'
  let value
}
```

</CodeSurfer>

---

## Now let's handle fulfilment


<Notes>

- Fulfilment is just a transition of state and value to something new
- It's the same core concept between succeeding and failing, just different "state"

</Notes>

---

## Now let's handle fulfilment

<CodeSurfer>

```js
function Promise () {
  let state = 'PENDING'
  let value
}
```

```js
function Promise () {
  let state = 'PENDING'
  let value

  const resolve = (newValue) => {
    state = 'RESOLVED'
    value = newValue
  }
}
```

```js
function Promise () {
  let state = 'PENDING'
  let value

  const resolve = (newValue) => {
    state = 'RESOLVED'
    value = newValue
  }

  const reject = (newValue) => {
    state = 'REJECTED'
    value = newValue
  }
}
```

```js 5:13
function Promise () {
  let state = 'PENDING'
  let value

  const resolve = (newValue) => {
    state = 'RESOLVED'
    value = newValue
  }

  const reject = (newValue) => {
    state = 'REJECTED'
    value = newValue
  }
}
```

```js
function Promise () {
  let state = 'PENDING'
  let value

  const fulfill = (newState, newValue) => {
    state = newState
    value = newValue
  }

  const resolve = (newValue) => fulfill('RESOLVED', newValue)
  const reject = (newValue) => fulfill('REJECTED', newValue)
}
```

</CodeSurfer>

---

## A quick reminder on how to make a Promise

<CodeSurfer>

```js title="We want to be able to use it like this"
const myPromise = Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('Hello, world!')
  }, 1000)
})
```

```js 1[19:26],5[2] title="Promise needs to take an argument!"
const myPromise = Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('Hello, world!')
  }, 1000)
})
```

```js 1[27:48],2:4,5[1] title="Promise needs to take an argument!"
const myPromise = Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('Hello, world!')
  }, 1000)
})
```

</CodeSurfer>

---

## Let's start using parameters

<CodeSurfer>

```js 1
function Promise () {
  let state = 'PENDING'
  let value

  const fulfill = (newState, newValue) => {
    state = newState
    value = newValue
  }

  const resolve = (newValue) => fulfill('RESOLVED', newValue)
  const reject = (newValue) => fulfill('REJECTED', newValue)
}
```

```js 1
function Promise (handler) {
  let state = 'PENDING'
  let value

  const fulfill = (newState, newValue) => {
    state = newState
    value = newValue
  }

  const resolve = (newValue) => fulfill('RESOLVED', newValue)
  const reject = (newValue) => fulfill('REJECTED', newValue)
}
```

```js
function Promise (handler) {
  let state = 'PENDING'
  let value

  const fulfill = (newState, newValue) => {
    state = newState
    value = newValue
  }

  const resolve = (newValue) => fulfill('RESOLVED', newValue)
  const reject = (newValue) => fulfill('REJECTED', newValue)
}
```

```js
function Promise (handler) {
  let state = 'PENDING'
  let value

  const fulfill = (newState, newValue) => {
    state = newState
    value = newValue
  }

  const resolve = (newValue) => fulfill('RESOLVED', newValue)
  const reject = (newValue) => fulfill('REJECTED', newValue)

  handler(resolve, reject)
}
```

```js 10[9:15],11[9:14],13
function Promise (handler) {
  let state = 'PENDING'
  let value

  const fulfill = (newState, newValue) => {
    state = newState
    value = newValue
  }

  const resolve = (newValue) => fulfill('RESOLVED', newValue)
  const reject = (newValue) => fulfill('REJECTED', newValue)

  handler(resolve, reject)
}
```

</CodeSurfer>

<Notes>

- So now we can do the whole setTimeout thing we had at the beginning

</Notes>

---

<CodeSurferColumns>

<CSStep>


```js
function Promise (handler) {
  let state = 'PENDING'
  let value

  const fulfill = (newState, newValue) => {
    state = newState
    value = newValue
  }

  const resolve = (newValue) => fulfill('RESOLVED', newValue)
  const reject = (newValue) => fulfill('REJECTED', newValue)

  handler(resolve, reject)
}
```

```js
const myPromise = Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('Hello, world!')
  }, 1000)
})
```

</CSStep>

<CSStep>

```js
function Promise (handler) {
  let state = 'PENDING'
  let value

  const fulfill = (newState, newValue) => {
    state = newState
    value = newValue
  }

  const resolve = (newValue) => fulfill('RESOLVED', newValue)
  const reject = (newValue) => fulfill('REJECTED', newValue)

  handler(resolve, reject)
}
```

```js 1[27:48],2:4,5[1]
const myPromise = Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('Hello, world!')
  }, 1000)
})
```

</CSStep>

<CSStep>

```js 1[19:25]
function Promise (handler) {
  let state = 'PENDING'
  let value

  const fulfill = (newState, newValue) => {
    state = newState
    value = newValue
  }

  const resolve = (newValue) => fulfill('RESOLVED', newValue)
  const reject = (newValue) => fulfill('REJECTED', newValue)

  handler(resolve, reject)
}
```

```js 1[27:48],2:4,5[1]
const myPromise = Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('Hello, world!')
  }, 1000)
})
```

</CSStep>

<CSStep>

```js 13
function Promise (handler) {
  let state = 'PENDING'
  let value

  const fulfill = (newState, newValue) => {
    state = newState
    value = newValue
  }

  const resolve = (newValue) => fulfill('RESOLVED', newValue)
  const reject = (newValue) => fulfill('REJECTED', newValue)

  handler(resolve, reject)
}
```

```js 1[27:48],2:4,5[1]
const myPromise = Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('Hello, world!')
  }, 1000)
})
```

</CSStep>

<CSStep>

```js 13
function Promise (handler) {
  let state = 'PENDING'
  let value

  const fulfill = (newState, newValue) => {
    state = newState
    value = newValue
  }

  const resolve = (newValue) => fulfill('RESOLVED', newValue)
  const reject = (newValue) => fulfill('REJECTED', newValue)

  handler(resolve, reject)
}
```

```js 1[28:42],3
const myPromise = Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('Hello, world!')
  }, 1000)
})
```

</CSStep>

</CodeSurferColumns>

<Notes>

- This should look familiar. It's how we make a Promise instance
- But we still can't access the resolved values

</Notes>

---

# We need `.then` and `.catch`

---

## Promises represent __eventual__ completion

<Steps>

So we need to store our handler so we only call it when ready

</Steps>

---

<CodeSurfer>

```js
function Promise (handler) {
  let state = 'PENDING'
  let value

  const fulfill = (newState, newValue) => {
    state = newState
    value = newValue
  }

  const resolve = (newValue) => fulfill('RESOLVED', newValue)
  const reject = (newValue) => fulfill('REJECTED', newValue)

  handler(resolve, reject)
}
```

```js
function Promise (handler) {
  let state = 'PENDING'
  let value

  const fulfill = (newState, newValue) => {
    state = newState
    value = newValue
  }

  const resolve = (newValue) => fulfill('RESOLVED', newValue)
  const reject = (newValue) => fulfill('REJECTED', newValue)

  handler(resolve, reject)

  return {
    then: () => {
      // TODO: Implement
    },
    catch: () => {
      // TODO: Implement
    }
  }
}
```

```js
function Promise (handler) {
  let state = 'PENDING'
  let value

  const fulfill = (newState, newValue) => {
    state = newState
    value = newValue
  }

  const resolve = (newValue) => fulfill('RESOLVED', newValue)
  const reject = (newValue) => fulfill('REJECTED', newValue)

  handler(resolve, reject)

  return {
    then: (thenHandler) => {
      // TODO: Implement
    },
    catch: () => {
      // TODO: Implement
    }
  }
}
```

```js
function Promise (handler) {
  let state = 'PENDING'
  let value

  const fulfill = (newState, newValue) => {
    state = newState
    value = newValue
  }

  const resolve = (newValue) => fulfill('RESOLVED', newValue)
  const reject = (newValue) => fulfill('REJECTED', newValue)

  handler(resolve, reject)

  return {
    then: (thenHandler) => {
      if (state === 'RESOLVED') {
        thenHandler(value) // but what if we're still pending?
      }
    },
    catch: () => {
      // TODO: Implement
    }
  }
}
```

```js
function Promise (handler) {
  let state = 'PENDING'
  let value

  const fulfill = (newState, newValue) => {
    state = newState
    value = newValue
  }

  const resolve = (newValue) => fulfill('RESOLVED', newValue)
  const reject = (newValue) => fulfill('REJECTED', newValue)

  handler(resolve, reject)

  return {
    then: (thenHandler) => {
      // TODO: Implement
    },
    catch: () => {
      // TODO: Implement
    }
  }
}
```

```js
function Promise (handler) {
  let state = 'PENDING'
  let value
  let fulfillmentHandler

  const fulfill = (newState, newValue) => {
    state = newState
    value = newValue
  }

  const resolve = (newValue) => fulfill('RESOLVED', newValue)
  const reject = (newValue) => fulfill('REJECTED', newValue)

  handler(resolve, reject)

  return {
    then: (thenHandler) => {
      // TODO: Implement
    },
    catch: () => {
      // TODO: Implement
    }
  }
}
```

</CodeSurfer>

---

## What does `fulfillmentHandler` need to know?

<Steps>

- Whether it should invoke on success or failure (`then` or `catch`)
- What value it should pass through to the `then` or `catch`
- Oh and we should only invoke it when the Promise is fulfilled

</Steps>

---

<CodeSurfer>

```js
function Promise (handler) {
  let state = 'PENDING'
  let value
  let fulfillmentHandler

  const fulfill = (newState, newValue) => {
    state = newState
    value = newValue
  }

  const resolve = (newValue) => fulfill('RESOLVED', newValue)
  const reject = (newValue) => fulfill('REJECTED', newValue)

  handler(resolve, reject)

  return {
    then: (thenHandler) => {
      // TODO: Implement
    },
    catch: () => {
      // TODO: Implement
    }
  }
}
```

```js
function Promise (handler) {
  let state = 'PENDING'
  let value
  let fulfillmentHandler

  const fulfill = (newState, newValue) => {
    state = newState
    value = newValue
  }

  const onFulfillment = (newFulfillmentHandler) => {
    if (state === 'PENDING') {
      fulfillmentHandler = newFulfillmentHandler
    }
  }

  const resolve = (newValue) => fulfill('RESOLVED', newValue)
  const reject = (newValue) => fulfill('REJECTED', newValue)

  handler(resolve, reject)

  return {
    then: (thenHandler) => {
      // TODO: Implement
    },
    catch: () => {
      // TODO: Implement
    }
  }
}
```

```js
function Promise (handler) {
  let state = 'PENDING'
  let value
  let fulfillmentHandler

  const fulfill = (newState, newValue) => {
    state = newState
    value = newValue
  }

  const onFulfillment = (newFulfillmentHandler) => {
    if (state === 'PENDING') {
      fulfillmentHandler = newFulfillmentHandler
    } else {
      newFulfillmentHandler(value)
    }
  }

  const resolve = (newValue) => fulfill('RESOLVED', newValue)
  const reject = (newValue) => fulfill('REJECTED', newValue)

  handler(resolve, reject)

  return {
    then: (thenHandler) => {
      // TODO: Implement
    },
    catch: () => {
      // TODO: Implement
    }
  }
}
```

```js
function Promise (handler) {
  let state = 'PENDING'
  let value
  let fulfillmentHandler

  const fulfill = (newState, newValue) => {
    state = newState
    value = newValue
    fulfillmentHandler && fulfillmentHandler(value)
  }

  const onFulfillment = (newFulfillmentHandler) => {
    if (state === 'PENDING') {
      fulfillmentHandler = newFulfillmentHandler
    } else {
      newFulfillmentHandler(value)
    }
  }

  const resolve = (newValue) => fulfill('RESOLVED', newValue)
  const reject = (newValue) => fulfill('REJECTED', newValue)

  handler(resolve, reject)

  return {
    then: (thenHandler) => {
      // TODO: Implement
    },
    catch: () => {
      // TODO: Implement
    }
  }
}
```

```js
function Promise (handler) {
  let state = 'PENDING'
  let value
  let fulfillmentHandler

  const fulfill = (newState, newValue) => {
    state = newState
    value = newValue
    fulfillmentHandler && fulfillmentHandler(value)
  }

  const onFulfillment = (newFulfillmentHandler) => {
    if (state === 'PENDING') {
      fulfillmentHandler = newFulfillmentHandler
    } else {
      newFulfillmentHandler(value)
    }
  }

  const resolve = (newValue) => fulfill('RESOLVED', newValue)
  const reject = (newValue) => fulfill('REJECTED', newValue)

  handler(resolve, reject)

  return {
    then: (thenHandler) => {
      onFulfillment(thenHandler)
    },
    catch: () => {
      // TODO: Implement
    }
  }
}
```

```js
function Promise (handler) {
  let state = 'PENDING'
  let value
  let fulfillmentHandler

  const fulfill = (newState, newValue) => {
    state = newState
    value = newValue
    fulfillmentHandler && fulfillmentHandler(value)
  }

  const onFulfillment = (newFulfillmentHandler) => {
    if (state === 'PENDING') {
      fulfillmentHandler = newFulfillmentHandler
    } else {
      newFulfillmentHandler(value)
    }
  }

  const resolve = (newValue) => fulfill('RESOLVED', newValue)
  const reject = (newValue) => fulfill('REJECTED', newValue)

  handler(resolve, reject)

  return {
    then: (thenHandler) => {
      onFulfillment((value) => {
        if (state === 'RESOLVED') {
          thenHandler(value)
        }
      })
    },
    catch: () => {
      // TODO: Implement
    }
  }
}
```

```js
function Promise (handler) {
  let state = 'PENDING'
  let value
  let fulfillmentHandler

  const fulfill = (newState, newValue) => {
    state = newState
    value = newValue
    fulfillmentHandler && fulfillmentHandler(value)
  }

  const onFulfillment = (newFulfillmentHandler) => {
    if (state === 'PENDING') {
      fulfillmentHandler = newFulfillmentHandler
    } else {
      newFulfillmentHandler(value)
    }
  }

  const resolve = (newValue) => fulfill('RESOLVED', newValue)
  const reject = (newValue) => fulfill('REJECTED', newValue)

  handler(resolve, reject)

  return {
    then: (thenHandler) => {
      onFulfillment((value) => {
        if (state === 'RESOLVED') {
          thenHandler(value)
        }
      })
    },
    catch: () => {
      // TODO: Implement
    }
  }
}
```

</CodeSurfer>

---

## We can run this!

---

<CodeSurfer>

```js 26:32
function Promise (handler) {
  let state = 'PENDING'
  let value
  let fulfillmentHandler

  const fulfill = (newState, newValue) => {
    state = newState
    value = newValue
    fulfillmentHandler && fulfillmentHandler(value)
  }

  const onFulfillment = (newFulfillmentHandler) => {
    if (state === 'PENDING') {
      fulfillmentHandler = newFulfillmentHandler
    } else {
      newFulfillmentHandler(value)
    }
  }

  const resolve = (newValue) => fulfill('RESOLVED', newValue)
  const reject = (newValue) => fulfill('REJECTED', newValue)

  handler(resolve, reject)

  return {
    then: (thenHandler) => {
      onFulfillment((value) => {
        if (state === 'RESOLVED') {
          thenHandler(value)
        }
      })
    },
    catch: () => {
      // TODO: Implement
    }
  }
}
```

```js
function Promise (handler) {
  let state = 'PENDING'
  let value
  let fulfillmentHandler

  const fulfill = (newState, newValue) => {
    state = newState
    value = newValue
    fulfillmentHandler && fulfillmentHandler(value)
  }

  const onFulfillment = (newFulfillmentHandler) => {
    if (state === 'PENDING') {
      fulfillmentHandler = newFulfillmentHandler
    } else {
      newFulfillmentHandler(value)
    }
  }

  const resolve = (newValue) => fulfill('RESOLVED', newValue)
  const reject = (newValue) => fulfill('REJECTED', newValue)

  handler(resolve, reject)

  return {
    then: (thenHandler) => {
      return new Promise((resolve, reject) => {
        // TODO: Implement
      })
    },
    catch: () => {
      // TODO: Implement
    }
  }
}
```

```js
function Promise (handler) {
  let state = 'PENDING'
  let value
  let fulfillmentHandler

  const fulfill = (newState, newValue) => {
    state = newState
    value = newValue
    fulfillmentHandler && fulfillmentHandler(value)
  }

  const onFulfillment = (newFulfillmentHandler) => {
    if (state === 'PENDING') {
      fulfillmentHandler = newFulfillmentHandler
    } else {
      newFulfillmentHandler(value)
    }
  }

  const resolve = (newValue) => fulfill('RESOLVED', newValue)
  const reject = (newValue) => fulfill('REJECTED', newValue)

  handler(resolve, reject)

  return {
    then: (thenHandler) => {
      return new Promise((resolve, reject) => {
        onFulfillment((value) => {
          if (state === 'REJECTED') {
            reject(value)

            return
          }

          // TODO: Logic where we know we're in a resolved state
        })
      })
    },
    catch: () => {
      // TODO: Implement
    }
  }
}
```

```js
function Promise (handler) {
  let state = 'PENDING'
  let value
  let fulfillmentHandler

  const fulfill = (newState, newValue) => {
    state = newState
    value = newValue
    fulfillmentHandler && fulfillmentHandler(value)
  }

  const onFulfillment = (newFulfillmentHandler) => {
    if (state === 'PENDING') {
      fulfillmentHandler = newFulfillmentHandler
    } else {
      newFulfillmentHandler(value)
    }
  }

  const resolve = (newValue) => fulfill('RESOLVED', newValue)
  const reject = (newValue) => fulfill('REJECTED', newValue)

  handler(resolve, reject)

  return {
    then: (thenHandler) => {
      return new Promise((resolve, reject) => {
        onFulfillment((value) => {
          if (state === 'REJECTED') {
            reject(value)

            return
          }

          resolve(thenHandler(value))
        })
      })
    },
    catch: () => {
      // TODO: Implement
    }
  }
}
```

</CodeSurfer>

---

# Demo time (again)

---

<CodeSurfer>

```js 35
function Promise (handler) {
  let state = 'PENDING'
  let value
  let fulfillmentHandler

  const fulfill = (newState, newValue) => {
    state = newState
    value = newValue
    fulfillmentHandler && fulfillmentHandler(value)
  }

  const onFulfillment = (newFulfillmentHandler) => {
    if (state === 'PENDING') {
      fulfillmentHandler = newFulfillmentHandler
    } else {
      newFulfillmentHandler(value)
    }
  }

  const resolve = (newValue) => fulfill('RESOLVED', newValue)
  const reject = (newValue) => fulfill('REJECTED', newValue)

  handler(resolve, reject)

  return {
    then: (thenHandler) => {
      return new Promise((resolve, reject) => {
        onFulfillment((value) => {
          if (state === 'REJECTED') {
            reject(value)

            return
          }

          resolve(thenHandler(value)) // but what if thenHandler() returns a promise?
        })
      })
    },
    catch: () => {
      // TODO: Implement
    }
  }
}
```

```js
function Promise (handler) {
  let state = 'PENDING'
  let value
  let fulfillmentHandler

  const fulfill = (newState, newValue) => {
    state = newState
    value = newValue
    fulfillmentHandler && fulfillmentHandler(value)
  }

  const onFulfillment = (newFulfillmentHandler) => {
    if (state === 'PENDING') {
      fulfillmentHandler = newFulfillmentHandler
    } else {
      newFulfillmentHandler(value)
    }
  }

  const resolve = (newValue) => fulfill('RESOLVED', newValue)
  const reject = (newValue) => fulfill('REJECTED', newValue)

  handler(resolve, reject)

  return {
    then: (thenHandler) => {
      return new Promise((resolve, reject) => {
        onFulfillment((value) => {
          if (state === 'REJECTED') {
            reject(value)

            return
          }

          const result = thenHandler(value)
        })
      })
    },
    catch: () => {
      // TODO: Implement
    }
  }
}
```

```js
function Promise (handler) {
  let state = 'PENDING'
  let value
  let fulfillmentHandler

  const fulfill = (newState, newValue) => {
    state = newState
    value = newValue
    fulfillmentHandler && fulfillmentHandler(value)
  }

  const onFulfillment = (newFulfillmentHandler) => {
    if (state === 'PENDING') {
      fulfillmentHandler = newFulfillmentHandler
    } else {
      newFulfillmentHandler(value)
    }
  }

  const resolve = (newValue) => fulfill('RESOLVED', newValue)
  const reject = (newValue) => fulfill('REJECTED', newValue)

  handler(resolve, reject)

  return {
    then: (thenHandler) => {
      return new Promise((resolve, reject) => {
        onFulfillment((value) => {
          if (state === 'REJECTED') {
            reject(value)

            return
          }

          const result = thenHandler(value)

          if (typeof result?.then === 'function') {
            // it's thennable, it's a promise!
            // TODO: implement
          } else {
            resolve(result)
          }
        })
      })
    },
    catch: () => {
      // TODO: Implement
    }
  }
}
```

```js
function Promise (handler) {
  let state = 'PENDING'
  let value
  let fulfillmentHandler

  const fulfill = (newState, newValue) => {
    state = newState
    value = newValue
    fulfillmentHandler && fulfillmentHandler(value)
  }

  const onFulfillment = (newFulfillmentHandler) => {
    if (state === 'PENDING') {
      fulfillmentHandler = newFulfillmentHandler
    } else {
      newFulfillmentHandler(value)
    }
  }

  const resolve = (newValue) => fulfill('RESOLVED', newValue)
  const reject = (newValue) => fulfill('REJECTED', newValue)

  handler(resolve, reject)

  return {
    then: (thenHandler) => {
      return new Promise((resolve, reject) => {
        onFulfillment((value) => {
          if (state === 'REJECTED') {
            reject(value)

            return
          }

          const result = thenHandler(value)

          if (typeof result?.then === 'function') {
            result.then(resolve).catch(reject)
          } else {
            resolve(result)
          }
        })
      })
    },
    catch: () => {
      // TODO: Implement
    }
  }
}
```

</CodeSurfer>

---

# And another live demo

---


# Time to implement `.catch`

<Steps>

It's probably simpler than you expect

</Steps>

---

<CodeSurfer>

```js 26:44
function Promise (handler) {
  let state = 'PENDING'
  let value
  let fulfillmentHandler

  const fulfill = (newState, newValue) => {
    state = newState
    value = newValue
    fulfillmentHandler && fulfillmentHandler(value)
  }

  const onFulfillment = (newFulfillmentHandler) => {
    if (state === 'PENDING') {
      fulfillmentHandler = newFulfillmentHandler
    } else {
      newFulfillmentHandler(value)
    }
  }

  const resolve = (newValue) => fulfill('RESOLVED', newValue)
  const reject = (newValue) => fulfill('REJECTED', newValue)

  handler(resolve, reject)

  return {
    then: (thenHandler) => {
      return new Promise((resolve, reject) => {
        onFulfillment((value) => {
          if (state === 'REJECTED') {
            reject(value)

            return
          }

          const result = thenHandler(value)

          if (typeof result?.then === 'function') {
            result.then(resolve).catch(reject)
          } else {
            resolve(result)
          }
        })
      })
    },
    catch: () => {
      // TODO: Implement
    }
  }
}
```

```js
function Promise (handler) {
  let state = 'PENDING'
  let value
  let fulfillmentHandler

  const fulfill = (newState, newValue) => {
    state = newState
    value = newValue
    fulfillmentHandler && fulfillmentHandler(value)
  }

  const onFulfillment = (newFulfillmentHandler) => {
    if (state === 'PENDING') {
      fulfillmentHandler = newFulfillmentHandler
    } else {
      newFulfillmentHandler(value)
    }
  }

  const resolve = (newValue) => fulfill('RESOLVED', newValue)
  const reject = (newValue) => fulfill('REJECTED', newValue)

  handler(resolve, reject)

  return {
    then: (thenHandler) => {
      return new Promise((resolve, reject) => {
        onFulfillment((value) => {
          if (state === 'REJECTED') {
            reject(value)

            return
          }

          const result = thenHandler(value)

          if (typeof result?.then === 'function') {
            result.then(resolve).catch(reject)
          } else {
            resolve(result)
          }
        })
      })
    },
    catch: () => {
      return new Promise((resolve, reject) => {
        onFulfillment((value) => {
          if (state === 'REJECTED') {
            reject(value)

            return
          }

          const result = thenHandler(value)

          if (typeof result?.then === 'function') {
            result.then(resolve).catch(reject)
          } else {
            resolve(result)
          }
        })
      })
    }
  }
}
```

```js 48:49
function Promise (handler) {
  let state = 'PENDING'
  let value
  let fulfillmentHandler

  const fulfill = (newState, newValue) => {
    state = newState
    value = newValue
    fulfillmentHandler && fulfillmentHandler(value)
  }

  const onFulfillment = (newFulfillmentHandler) => {
    if (state === 'PENDING') {
      fulfillmentHandler = newFulfillmentHandler
    } else {
      newFulfillmentHandler(value)
    }
  }

  const resolve = (newValue) => fulfill('RESOLVED', newValue)
  const reject = (newValue) => fulfill('REJECTED', newValue)

  handler(resolve, reject)

  return {
    then: (thenHandler) => {
      return new Promise((resolve, reject) => {
        onFulfillment((value) => {
          if (state === 'REJECTED') {
            reject(value)

            return
          }

          const result = thenHandler(value)

          if (typeof result?.then === 'function') {
            result.then(resolve).catch(reject)
          } else {
            resolve(result)
          }
        })
      })
    },
    catch: () => {
      return new Promise((resolve, reject) => {
        onFulfillment((value) => {
          if (state === 'REJECTED') {
            reject(value)

            return
          }

          const result = thenHandler(value)

          if (typeof result?.then === 'function') {
            result.then(resolve).catch(reject)
          } else {
            resolve(result)
          }
        })
      })
    }
  }
}
```

```js
function Promise (handler) {
  let state = 'PENDING'
  let value
  let fulfillmentHandler

  const fulfill = (newState, newValue) => {
    state = newState
    value = newValue
    fulfillmentHandler && fulfillmentHandler(value)
  }

  const onFulfillment = (newFulfillmentHandler) => {
    if (state === 'PENDING') {
      fulfillmentHandler = newFulfillmentHandler
    } else {
      newFulfillmentHandler(value)
    }
  }

  const resolve = (newValue) => fulfill('RESOLVED', newValue)
  const reject = (newValue) => fulfill('REJECTED', newValue)

  handler(resolve, reject)

  return {
    then: (thenHandler) => {
      return new Promise((resolve, reject) => {
        onFulfillment((value) => {
          if (state === 'REJECTED') {
            reject(value)

            return
          }

          const result = thenHandler(value)

          if (typeof result?.then === 'function') {
            result.then(resolve).catch(reject)
          } else {
            resolve(result)
          }
        })
      })
    },
    catch: () => {
      return new Promise((resolve, reject) => {
        onFulfillment((value) => {
          if (state === 'RESOLVED') {
            resolve(value)

            return
          }

          const result = thenHandler(value)

          if (typeof result?.then === 'function') {
            result.then(resolve).catch(reject)
          } else {
            resolve(result)
          }
        })
      })
    }
  }
}
```

```js 45,54
function Promise (handler) {
  let state = 'PENDING'
  let value
  let fulfillmentHandler

  const fulfill = (newState, newValue) => {
    state = newState
    value = newValue
    fulfillmentHandler && fulfillmentHandler(value)
  }

  const onFulfillment = (newFulfillmentHandler) => {
    if (state === 'PENDING') {
      fulfillmentHandler = newFulfillmentHandler
    } else {
      newFulfillmentHandler(value)
    }
  }

  const resolve = (newValue) => fulfill('RESOLVED', newValue)
  const reject = (newValue) => fulfill('REJECTED', newValue)

  handler(resolve, reject)

  return {
    then: (thenHandler) => {
      return new Promise((resolve, reject) => {
        onFulfillment((value) => {
          if (state === 'REJECTED') {
            reject(value)

            return
          }

          const result = thenHandler(value)

          if (typeof result?.then === 'function') {
            result.then(resolve).catch(reject)
          } else {
            resolve(result)
          }
        })
      })
    },
    catch: () => {
      return new Promise((resolve, reject) => {
        onFulfillment((value) => {
          if (state === 'RESOLVED') {
            resolve(value)

            return
          }

          const result = thenHandler(value)

          if (typeof result?.then === 'function') {
            result.then(resolve).catch(reject)
          } else {
            resolve(result)
          }
        })
      })
    }
  }
}
```

```js
function Promise (handler) {
  let state = 'PENDING'
  let value
  let fulfillmentHandler

  const fulfill = (newState, newValue) => {
    state = newState
    value = newValue
    fulfillmentHandler && fulfillmentHandler(value)
  }

  const onFulfillment = (newFulfillmentHandler) => {
    if (state === 'PENDING') {
      fulfillmentHandler = newFulfillmentHandler
    } else {
      newFulfillmentHandler(value)
    }
  }

  const resolve = (newValue) => fulfill('RESOLVED', newValue)
  const reject = (newValue) => fulfill('REJECTED', newValue)

  handler(resolve, reject)

  return {
    then: (thenHandler) => {
      return new Promise((resolve, reject) => {
        onFulfillment((value) => {
          if (state === 'REJECTED') {
            reject(value)

            return
          }

          const result = thenHandler(value)

          if (typeof result?.then === 'function') {
            result.then(resolve).catch(reject)
          } else {
            resolve(result)
          }
        })
      })
    },
    catch: (catchHandler) => {
      return new Promise((resolve, reject) => {
        onFulfillment((value) => {
          if (state === 'RESOLVED') {
            resolve(value)

            return
          }

          const result = catchHandler(value)

          if (typeof result?.then === 'function') {
            result.then(resolve).catch(reject)
          } else {
            resolve(result)
          }
        })
      })
    }
  }
}
```

</CodeSurfer>

---

# Okay let's trigger some errors

---

# One more thing

---

### You can share Promises

<CodeSurfer>

```js
const myFirstPromise = eventuallyAddOne(5)

myFirstPromise
  .then(takeTwo)
  .then(console.log)

myFirstPromise
  .then(eventuallyAddOne)
  .then(console.log)
```

</CodeSurfer>

---

### But we only allow for one handler

<CodeSurfer>

```js 4,14
function Promise (handler) {
  let state = 'PENDING'
  let value
  let fulfillmentHandler

  const fulfill = (newState, newValue) => {
    state = newState
    value = newValue
    fulfillmentHandler && fulfillmentHandler(value)
  }

  const onFulfillment = (newFulfillmentHandler) => {
    if (state === 'PENDING') {
      fulfillmentHandler = newFulfillmentHandler
    } else {
      newFulfillmentHandler(value)
    }
  }

  const resolve = (newValue) => fulfill('RESOLVED', newValue)
  const reject = (newValue) => fulfill('REJECTED', newValue)

  handler(resolve, reject)

  return {
    then: (thenHandler) => {
      return new Promise((resolve, reject) => {
        onFulfillment((value) => {
          if (state === 'REJECTED') {
            reject(value)

            return
          }

          const result = thenHandler(value)

          if (typeof result?.then === 'function') {
            result.then(resolve).catch(reject)
          } else {
            resolve(result)
          }
        })
      })
    },
    catch: (catchHandler) => {
      return new Promise((resolve, reject) => {
        onFulfillment((value) => {
          if (state === 'RESOLVED') {
            resolve(value)

            return
          }

          const result = catchHandler(value)

          if (typeof result?.then === 'function') {
            result.then(resolve).catch(reject)
          } else {
            resolve(result)
          }
        })
      })
    }
  }
}
```

</CodeSurfer>

---

If only there were a data type which allowed for a collection of other data 🤔

<Steps>

Okay yes, let's use an array.

</Steps>

---

### But we only allow for one handler

<CodeSurfer>

```js 4,14
function Promise (handler) {
  let state = 'PENDING'
  let value
  let fulfillmentHandler

  const fulfill = (newState, newValue) => {
    state = newState
    value = newValue
    fulfillmentHandler && fulfillmentHandler(value)
  }

  const onFulfillment = (newFulfillmentHandler) => {
    if (state === 'PENDING') {
      fulfillmentHandler = newFulfillmentHandler
    } else {
      newFulfillmentHandler(value)
    }
  }

  const resolve = (newValue) => fulfill('RESOLVED', newValue)
  const reject = (newValue) => fulfill('REJECTED', newValue)

  handler(resolve, reject)

  return {
    then: (thenHandler) => {
      return new Promise((resolve, reject) => {
        onFulfillment((value) => {
          if (state === 'REJECTED') {
            reject(value)

            return
          }

          const result = thenHandler(value)

          if (typeof result?.then === 'function') {
            result.then(resolve).catch(reject)
          } else {
            resolve(result)
          }
        })
      })
    },
    catch: (catchHandler) => {
      return new Promise((resolve, reject) => {
        onFulfillment((value) => {
          if (state === 'RESOLVED') {
            resolve(value)

            return
          }

          const result = catchHandler(value)

          if (typeof result?.then === 'function') {
            result.then(resolve).catch(reject)
          } else {
            resolve(result)
          }
        })
      })
    }
  }
}
```

```js
function Promise (handler) {
  let state = 'PENDING'
  let value
  let fulfillmentHandlers = []

  const fulfill = (newState, newValue) => {
    state = newState
    value = newValue
    fulfillmentHandler && fulfillmentHandler(value)
  }

  const onFulfillment = (newFulfillmentHandler) => {
    if (state === 'PENDING') {
      fulfillmentHandlers.push(newFulfillmentHandler)
    } else {
      newFulfillmentHandler(value)
    }
  }

  const resolve = (newValue) => fulfill('RESOLVED', newValue)
  const reject = (newValue) => fulfill('REJECTED', newValue)

  handler(resolve, reject)

  return {
    then: (thenHandler) => {
      return new Promise((resolve, reject) => {
        onFulfillment((value) => {
          if (state === 'REJECTED') {
            reject(value)

            return
          }

          const result = thenHandler(value)

          if (typeof result?.then === 'function') {
            result.then(resolve).catch(reject)
          } else {
            resolve(result)
          }
        })
      })
    },
    catch: (catchHandler) => {
      return new Promise((resolve, reject) => {
        onFulfillment((value) => {
          if (state === 'RESOLVED') {
            resolve(value)

            return
          }

          const result = catchHandler(value)

          if (typeof result?.then === 'function') {
            result.then(resolve).catch(reject)
          } else {
            resolve(result)
          }
        })
      })
    }
  }
}
```

```js 9
function Promise (handler) {
  let state = 'PENDING'
  let value
  let fulfillmentHandlers = []

  const fulfill = (newState, newValue) => {
    state = newState
    value = newValue
    fulfillmentHandler && fulfillmentHandler(value)
  }

  const onFulfillment = (newFulfillmentHandler) => {
    if (state === 'PENDING') {
      fulfillmentHandlers.push(newFulfillmentHandler)
    } else {
      newFulfillmentHandler(value)
    }
  }

  const resolve = (newValue) => fulfill('RESOLVED', newValue)
  const reject = (newValue) => fulfill('REJECTED', newValue)

  handler(resolve, reject)

  return {
    then: (thenHandler) => {
      return new Promise((resolve, reject) => {
        onFulfillment((value) => {
          if (state === 'REJECTED') {
            reject(value)

            return
          }

          const result = thenHandler(value)

          if (typeof result?.then === 'function') {
            result.then(resolve).catch(reject)
          } else {
            resolve(result)
          }
        })
      })
    },
    catch: (catchHandler) => {
      return new Promise((resolve, reject) => {
        onFulfillment((value) => {
          if (state === 'RESOLVED') {
            resolve(value)

            return
          }

          const result = catchHandler(value)

          if (typeof result?.then === 'function') {
            result.then(resolve).catch(reject)
          } else {
            resolve(result)
          }
        })
      })
    }
  }
}
```

```js
function Promise (handler) {
  let state = 'PENDING'
  let value
  let fulfillmentHandlers = []

  const fulfill = (newState, newValue) => {
    state = newState
    value = newValue
    fulfillmentHandlers.forEach((fh) => fh(value))
  }

  const onFulfillment = (newFulfillmentHandler) => {
    if (state === 'PENDING') {
      fulfillmentHandlers.push(newFulfillmentHandler)
    } else {
      newFulfillmentHandler(value)
    }
  }

  const resolve = (newValue) => fulfill('RESOLVED', newValue)
  const reject = (newValue) => fulfill('REJECTED', newValue)

  handler(resolve, reject)

  return {
    then: (thenHandler) => {
      return new Promise((resolve, reject) => {
        onFulfillment((value) => {
          if (state === 'REJECTED') {
            reject(value)

            return
          }

          const result = thenHandler(value)

          if (typeof result?.then === 'function') {
            result.then(resolve).catch(reject)
          } else {
            resolve(result)
          }
        })
      })
    },
    catch: (catchHandler) => {
      return new Promise((resolve, reject) => {
        onFulfillment((value) => {
          if (state === 'RESOLVED') {
            resolve(value)

            return
          }

          const result = catchHandler(value)

          if (typeof result?.then === 'function') {
            result.then(resolve).catch(reject)
          } else {
            resolve(result)
          }
        })
      })
    }
  }
}
```

</CodeSurfer>

---

# The last planned demo!

---

# Is this ECMAScript compliant?

No

<Steps>

- I mainly skipped a lot of error handling for brevity
- I didn't make the various convenience methods

</Steps>

---

<Steps>

- Promises are just objects with functions that eventually get called
- Promise internals are just a few things to store those functions for eventual invocation
- Promises are neat

</Steps>

---

Thanks!
